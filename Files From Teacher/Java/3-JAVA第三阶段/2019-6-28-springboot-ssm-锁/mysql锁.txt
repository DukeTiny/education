1. mysql数据库中，有2种锁：
	共享锁， 排他锁。

2. 共享锁和共享锁之间是兼容的
   排他锁与任何锁都不兼容。

3. 为数据加锁，有两种方式：
	a. 执行不同的sql语句时，会自动加不同锁。
	b. 手动加锁

4. select语句默认情况下，不加任何锁。
   insert、delete、update默认会加排他锁

5. 锁自从加上以后，直到事务结束后，才释放。

6. sql中，所有没有明显开启事务的时候，每一个sql语句都在一个独立的事务中。
   也就是说，在每一个sql语句前，会自动开始事务，sql语句执行后，会自动结束事务。


7. 为select语句操作的资源，
	添加共享锁：
	select * from user lock in share mode
	添加排他锁：
	select * from user for update

8. 锁按照粒度来划分，可以分为，
	表级锁
	行级锁

9. 更新锁：就是会在运行时变化的锁。
	一开始是共享锁，后来变为排他锁。

10. 意向锁： 给表上加的锁：
	sql语句本来想加排他或者共享锁，但是无法确定级别，只有在sql确定要操作的行数时，才能知道级别。
	在确定行数之前，只能是意向锁。

11. 悲观锁、乐观锁。
	就不是什么新的功能。没有新语法。
	
	悲观锁，就是程序员这个人很悲观，他认为他要读取的数据，总是会被其他事务影响。所以每次在读取数据前，
	都加上共享锁。  优点，数据一定是准确的，最新的，缺点就是降低并发性。

	乐观锁，就是程序员这个人很乐观，他认为他要读取的数据，很少会被其他事务影响。所以每次在读取数据前，
	都不加任何锁。  优点，高并发，缺点：数据不准确。
	
	乐观锁实现策略：
	1. 版本号
	2. 时间戳   
	
	12321321321321

	



12. 我们已经知道，select语句默认是不加锁的。  但是如果在serializable级别写，select会自动加上共享锁。
	直到结束事务才会释放锁。


拓展内容： oracle中只有2个事务隔离级别，但是能模拟出mysql中的4个级别的效果。 利用锁+级别。
	






	




